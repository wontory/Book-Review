# 1. 타입이란

## 1. 자료형으로서의 타입

- 변수: 값을 저장할 수 있는 공간이자 값을 가리키는 상징적인 이름
- 데이터 타입은 여러 종류의 데이터를 식별하는 분류 체계로 컴파일러에 값의 형태를 알려준다.
- 개발자는 타입을 사용해서 값의 종류를 명시할 수 있고 메모리를 더욱 효율적으로 사용할 수 있다.
  > 컴퓨터의 메모리 공간은 한정적이다. 값의 크기를 명시한다면 컴퓨터가 값을 참조할 때 한 번에 읽을 메모리 크기를 알 수 있어 값을 훼손하지 않고 가져올 수 있다.
- 자바스크립트의 7가지 데이터 타입
  - `undefined`
  - `null`
  - `Boolean`
  - `String`
  - `Symbol`
  - `Numeric(Number & BigInt)`
  - `Object`

## 2. 집합으로서의 타입

- 타입: 값이 가질 수 있는 유효한 범위의 집합
- 타입 시스템은 코드에서 사용되는 유효한 값의 범위를 제한해서 런타임에서 발생할 수 있는 유효하지 않은 값에 대한 에러를 방지해준다.
  - 함수의 매개변수 타입을 명시한다면 올바르지 않은 타입의 값으로 함수를 호출했을 때 타입스크립트 컴파일러는 곧바로 에러를 발생시킨다.

## 3. 정적 타입과 동적 타입

- 타입을 결정하는 시점에 따라 타입을 정적 타입(static type)과 동적 타입(dynamic type)으로 분류할 수 있다.
- 정적 타입 시스템에서는 모든 변수의 타입이 컴파일타임에 결정된다.
  - 코드 수준에서 개발자가 타입을 명시해줘야 한다.
  - 컴파일타임에 타입 에러를 발견할 수 있기 때문에 프로그램의 안정성을 보장할 수 있다.
- 동적 타입 시스템에서는 변수 타입이 런타임에서 결정된다.

  - 직접 타입을 정의해줄 필요가 없다.
  - 프로그램을 실행할 때 타입 에러가 발견되므로 언제 프로그램에 오류가 생길지 모르는 불안감에 휩싸이게 된다.

  > **컴파일타임과 런타임**  
  > 컴파일타임: 기계가 소스코드를 이해할 수 있도록 기계어로 변환되는 시점  
  > 런타임: 변환된 파일이 메모리에 적재되어 실행되는 시점

## 4. 강타입과 약타입

- 암묵적 타입 변환 여부에 따라 타입 시스템을 강타입(strong type)과 약타입(weakly type)으로 분류할 수 있다.
  > **암묵적 타입 변환(implicit coercion/conversion)**
  >
  > - 개발자가 의도적으로 타입을 명시하거나 바꾸지 않았는데도 컴파일러 또는 엔진 등에 의해서 런타임에 타입이 자동으로 변경되는 것
  > - 편리함을 제공하기도 하지만, 작성자의 의도와 다르게 동작할 수 있기 때문에 예기치 못한 오류가 발생할 가능성도 높아진다.
- 강타입: 서로 다른 타입을 갖는 값끼리 연산을 시도하면 컴파일러 또는 인터프리터에서 에러가 발생
- 약타입: 서로 다른 타입을 갖는 값끼리 연산할 때는 컴파일러 또는 인터프리터에서 내부적으로 판단해서 특정 값의 타입을 변환하여 연산을 수행한 후 값을 도출
  - 자바스크립트는 약타입 언어이기 때문에 런타임에서 발생할 수 있는 에러를 예측하고 방지하는 코드를 작성하는 것이 프로그램을 안전하게 만드는 데 도움이 된다.
- 타입스크립트는 두 가지 타입 시스템의 영향을 모두 받아 개발자가 직접 타입을 명시하거나, 타입스크립트가 타입을 추론하도록 하는 방식 중에서 선택할 수 있다.

## 5. 컴파일 방식

- 컴파일: 사람이 이해할 수 있는 방식으로 작성한 코드를 컴퓨터가 이해할 수 있는 기계어로 바꿔주는 과정
- 타입스크립트의 컴파일은 일반적인 컴파일과는 의미가 조금 다르다.
  - 타입스크립트를 컴파일하면 타입이 모두 제거된 자바스크립트 소스코드만이 남게 된다.  
    → 여전히 사람이 이해할 수 있는 방식
  - 타입스크립트가 탄생한 이유가 자바스크립트의 컴파일타임에 런타임 에러를 사전에 잡아내기 위한 것이기 때문

&nbsp;

# 2. 타입스크립트의 타입 시스템

## 1. 타입 애너테이션 방식

- 타입 애너테이션(type annotation): 변수나 상수 혹은 함수의 인자와 반환 값에 타입을 명시적으로 선언해서 어떤 타입 값이 저장될 것인지 컴파일러에 직접 알려주는 문법
- 변수 이름 뒤에 `: type` 구문을 붙여 데이터 타입을 명시
  ```ts
  let isDone: boolean = false;
  let decimal: number = 6;
  let color: string = "blue";
  let list: number[] = [1, 2, 3];
  let x: [string, number]; // tuple
  ```
- 타입스크립트는 기존 자바스크립트 코드에 점진적으로 타입을 적용할 수 있는 특징을 가지고 있다.

## 2. 구조적 타이핑

- 타입스크립트는 이름으로 타입을 구분하는 명목적인 타입 시스템과 달리 구조로 타입을 구분한다.

  > **명목적으로 구체화한 타입 시스템(Nominal Reified Type System)**
  >
  > - 값이나 객체는 하나의 구체적인 타입을 가지고 있고, 이 타입은 이름으로 구분되며 컴파일타임 이후에도 남아있다.
  > - 서로 다른 클래스끼리 명확한 상속 관계나 공통으로 가지고 있는 인터페이스가 없다면 타입은 서로 호환되지 않는다.

  ```ts
  interface Developer {
    faceValue: number;
  }

  interface BankNote {
    faceValue: number;
  }

  let developer: Developer = { faceValue: 52 };
  let bankNote: BankNote = { faceValue: 10000 };

  developer = bankNote; // OK
  bankNote = developer; // OK
  ```

## 3. 구조적 서브타이핑

- 구조적 서브타이핑: 객체가 가지고 있는 속성을 바탕으로 타입을 구분하는 것
- 타입스크립트의 타입은 값의 집합으로 생각할 수 있다.
  - 타입은 단지 집합에 포함되는 값이고 특정 값은 많은 집합에 포함될 수 있다.
- 서로 다른 두 타입 간의 호환성은 오로지 타입 내부의 구조에 의해 결정된다.

  - 이름이 다른 객체라도 가진 속성이 동일하다면 타입스크립트는 서로 호환이 가능한 동일한 타입으로 여긴다.
  - 타입 A가 타입 B의 서브타입이라면 A 타입의 인스턴스는 B 타입이 필요한 곳에 언제든지 위치할 수 있다. → 계층 구조로부터 자유롭다.

    ```ts
    interface Pet {
      name: string;
    }

    interface Cat {
      name: string;
      age: number;
    }

    let pet: Pet;
    let cat: Cat = { name: "Zag", age: 2 };

    // Cat은 Pet과 다른 타입으로 선언되었지만 Pet이 갖고있는 name이라는 속성을 갖고 있으므로 cat을 pet에 할당할 수 있다.
    pet = cat;

    class Person {
      name: string;
      age: number;

      constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
      }
    }

    class Developer {
      name: string;
      age: number;
      sleepTime: number;

      constructor(name: string, age: number, sleepTime: number) {
        this.name = name;
        this.age = age;
        this.sleepTime = sleepTime;
      }
    }

    function greet(p: Person) {
      console.log(`Hello, I'm ${p.name}`);
    }

    const developer = new Developer("zig", 20, 7);

    // Developer 클래스가 Person 클래스를 상속받지 않았는데도 Developer는 Person이 갖고 있는 속성을 가지고 있기 때문에 정상적으로 동작한다.
    greet(developer);
    ```

## 4. 자바스크립트를 닮은 타입스크립트

- 구조가 같더라도 이름이 다르면 다른 타입으로 취급하는 명목적 타이핑은 구조적 타이핑에 비해 안전하다.
- 그렇다면 타입스크립트는 왜 명목적 타이핑이 아닌 구조적 타이핑을 채택했을까?
- 자바스크립트는 본질적으로 덕 타이핑(duck typing)을 기반으로 한다.
  > **덕 타이핑(duck typing)**  
  > 어떤 타입에 부합하는 변수와 메서드를 가질 경우 해당 타입에 속하는 것으로 간주하는 방식  
  > "만약 어떤 새가 오리처럼 걷고, 헤엄치며 꽥꽥거리는 소리를 낸다면 나는 그 새를 오리라고 부를 것이다."
- 타입스크립트는 자바스크립트의 이런 동작을 그대로 모델링했고, 구조적 타이핑 덕분에 더욱 유연한 타이핑이 가능해졌다.

  - 쉬운 사용성과 안전성, 두 목표 사이의 균형

  > **덕 타이핑과 구조적 타이핑의 차이**  
  > 덕 타이핑은 런타임에 타입을 검사하고, 구조적 타이핑은 컴파일타임에 타입체커가 타입을 검사한다.

## 5. 구조적 타이핑의 결과

- 구조적 타이핑의 특징 때문에 객체에 다른 속성이 추가되었을 때 타입을 확정할 수 없어 에러가 발생하기도 한다.

  ```ts
  interface Cube {
    width: number;
    height: number;
    depth: number;
  }

  function addLines(c: Cube) {
    let total = 0;

    for (const axis of Object.keys(c)) {
      // Element implicitly has an 'any' type
      const length = c[axis];

      total += length;
    }
  }
  ```

  - `c[axis]`의 타입이 `number`라고 확정할 수 없어서 에러가 발생한다.
  - 타입스크립트 구조적 타이핑의 특징으로 `Cube` 타입 값이 들어갈 곳에 `name` 같은 추가 속성을 가진 객체도 할당할 수 있기 때문에 발생하는 문제

    ```ts
    const namedCube = {
      width: 6,
      height: 5,
      depth: 4,
      name: "SweetCube",
    };

    addLines(namedCube); // OK
    ```

- 이러한 한계를 극복하고자 타입스크립트에 명목적 타이핑 언어의 특징을 가미한 식별할 수 있는 유니온(Discriminated Unions) 같은 방법이 생겨났다.

## 6. 타입스크립트의 점진적 타입 확인

- 점진적 타입 검사: 컴파일타임에 타입을 검사하면서 필요에 따라 타입 선언 생략을 허용하는 방식
- 타입을 지정한 변수와 표현식은 정적으로 타입을 검사하지만, 타입 선언이 생략되면 동적으로 검사를 수행하며 암시적 타입 변환이 일어난다.

  ```ts
  function add(x, y) {
    return x + y;
  }

  // 위 코드는 아래와 같이 암시적 타입 변환이 일어난다.
  function add(x: any, y: any): any;
  ```

  > **any 타입**  
  > 타입스크립트 내 모든 타입의 종류를 포함하는 가장 상위 타입으로 어떤 타입 값이든 할당할 수 있다.  
  > 타입스크립트 컴파일 옵션인 noImplicitAny 값이 true일 때는 타입 애너테이션이 없을 때 변수가 any 타입으로 추론되는 것을 허락하지 않아 에러가 발생한다. (`noImplicitAny: true`를 권장)

- 타입스크립트는 자바스크립트의 슈퍼셋 언어이므로 모든 자바스크립트 코드는 타입스크립트 코드라고 봐도 무방하다. → `.ts` 파일에 자바스크립트 문법으로 코드를 작성해도 문제 X
  - 이러한 특징 때문에 타입스크립트의 타입 시스템은 정적 타입의 정확성을 100% 보장해주지 않는다.
  - 모든 변수와 표현식의 타입을 컴파일타임에 검사하지 않아도 되기 때문에 타입이 올바르게 정해지지 않으면 런타임에서 에러가 발생하기도 한다.

## 7. 자바스크립트 슈퍼셋으로서의 타입스크립트

- 타입스크립트는 기존 자바스크립트 코드에 정적인 타이핑을 추가한 것으로 자바스크립트의 상위 집합
- 타입스크립트 문법은 모든 자바스크립트 문법을 포함
- 모든 자바스크립트 코드는 타입스크립트라고 볼수 있지만, 모든 타입스크립트 코드가 자바스크립트 코드인 것은 아니다.
- 타입스크립트 컴파일러는 타입스크립트뿐만 아니라 일반 자바스크립트 프로그램에서도 유용하게 사용할 수 있다.

  ```ts
  function greet(name: string) {
    // TS: OK, JS: Unexpected token
    console.log("Hello", name);
  }

  let developer = "Colin";
  console.log(developer.toUppercase());
  // JS(runtime)
  // developer.toUppercase is not a function

  // TS(compiletime)
  // Property 'toUppercase' does not exist on type 'string'. Did you mean 'toUpperCase'?
  ```

## 8. 값 vs 타입

- 값: 프로그램이 처리하기 위해 메모리에 저장하는 모든 데이터 - 문자열, 숫자, 변수, 매개변수, 객체 등
  - 자바스크립트에서는 함수도 값이다. (런타임에 객체로 변환되기 때문)
- 타입스크립트는 변수, 매개변수, 객체 속성 등에 `: type` 형태로 타입을 명시하거나, `type`, `interface` 키워드로 커스텀 타입을 정의할 수 있다.
- 값 공간과 타입 공간의 이름은 서로 충돌하지 않기 때문에 타입과 변수를 같은 이름으로 정의할 수 있다.
  - 타입스크립트 문법인 `type`으로 선언한 내용은 자바스크립트 런타임에서 제거되기 때문
- 타입은 주로 타입선언(`:`) 또는 단언 문(`as`)으로 작성하고 값은 할당 연산자인 `=`으로 작성한다.

  > **구조 분해 할당(Destructuring assignment)**  
  > ES6부터 도입된 자바스크립트의 기능으로 배열이나 객체의 속성을 개별 변수로 분해하여 그 값을 변수에 할당하는 것
  >
  > 아래와 같이 구조 분해 할당 + 타입을 선언하면 값의 관점에서 `Person`과 `string`이 해석되기 때문에 오류가 발생한다.
  >
  > ```ts
  > // X
  > function email({ person: Person, subject: string, body: string }) {}
  >
  > // O
  > function email({
  >   person,
  >   subject,
  >   body,
  > }: {
  >   person: Person;
  >   subject: string;
  >   body: string;
  > });
  > ```

- 타입스크립트에서 자바스크립트의 키워드가 해석되는 방식

  |        키워드         | 값  | 타입 |
  | :-------------------: | :-: | :--: |
  |        `class`        |  Y  |  Y   |
  | `const`, `let`, `var` |  Y  |  N   |
  |        `enum`         |  Y  |  Y   |
  |      `function`       |  Y  |  N   |
  |      `interface`      |  N  |  Y   |
  |        `type`         |  N  |  Y   |
  |      `namespace`      |  Y  |  N   |

## 9. 타입을 확인하는 방법

- `typeof`, `instanceof`, 타입 단언을 사용해서 타입을 확인할 수 있다.
- 타입스크립트에서 `typeof` 연산자는 값에서 쓰일 때와 타입에서 쓰일 때의 역할이 다르다.
  - 값에서 사용된 `typeof`는 자바스크립트 런타임의 `typeof` 연산자가 된다.
  - 타입에서 사용된 `typeof`는 값을 읽고 타입스크립트 타입을 반환한다.
- `instanceof` 연산자를 사용하면 프로토타입 체이닝 어딘가에 생성자의 프로토타입 속성이 존재하는지 판단할 수 있고, 필터링으로 타입이 보장된 상태에서 안전하게 값의 타입을 정제하여 사용할 수 있다.
- `as` 키워드로 타입을 강제하는 타입 단언을 할 수 있다.
  - 해당 값의 타입을 더 잘 파악할 수 있을 대 사용되며 강제 형 변환과 유사한 기능을 제공한다.
  - 타입 캐스팅과 유사하지만 일치하는 개념은 아니다. (런타임에서는 효력을 발휘할 수 없다.)
- 이외에도 특정 조건을 검사해서 타입을 정제하고 타입 안정성을 높이는 타입 가드라는 패턴을 사용해 타입을 검사할 수 있다.

&nbsp;

# 3. 원시 타입

> **원시 값과 원시 래퍼 객체**  
> 자바스크립트의 내장 타입은 파스칼 표기법으로, 타입스크립트에서는 이에 대응하는 타입을 소문자로 표기한다.  
> 타입을 파스칼 표기법으로 표기하면 자바스크립트에서 이것을 원시 래퍼 객체라고 부른다. `null`과 `undefined`를 제외한 모든 원시 값은 해당 원시 값을 래핑한 객체를 가진다.  
> 원시 래퍼 객체는 원시 값이 아닌 객체이므로, 타입스크립트에서는 내장 원시 타입에 해당하는 타입을 파스칼 표기법으로 쓰지 않도록 주의해야 한다.  
> 타입스크립트에도 원시 래퍼 객체가 존재하는데 이것은 고유한 타입으로 분류되기 때문에 둘은 엄연히 다르다.

## 1. boolean

- `true`와 `false` 값만 할당할 수 있는 타입
- 자바스크립트에는 `boolean` 원시 값은 아니지만 형 변환을 통해 `true` / `false로` 취급되는 `Truthy` / `Falsy` 값이 존재한다.
  - 이 값은 `boolean` 원시 값이 아니므로 타입스크립트에서도 `boolean` 타입에 해당하지 않는다.

## 2. undefined

- 정의되지 않았다는 의미의 타입으로 오직 `undefined` 값만 할당할 수 있다.
- 일반적으로 초기화되지 않은 값을 의미하며 옵셔널로 지정되어 있는 속성에 대해서도 할당할 수 있다.

## 3. null

- 빈 값을 할당해야 할 때 사용하며 오직 `null`만 할당할 수 있다.
- 명시적, 의도적으로 값이 아직 비어있을 수 있음을 보여주기 위해 사용한다.
- `null`과 `undefined`가 비슷해보여도 엄연히 따로 존재하는 원시 값이기 때문에 서로의 타입에 할당할 수 없다.

## 4. number

- 숫자에 해당하는 모든 원시 값을 할당할 수 있다.
- 자바스크립트의 숫자는 정수, 부동소수점수를 구분하지 않는다.
- 자바스크립트에서 숫자에 해당하는 원시 값 중 `NaN`이나 `Infinity`도 포함된다.

## 5. bigInt

- ES2020에서 새롭게 도입된 데이터 타입으로 타입스크립트 3.2 버전부터 사용할 수 있다.
- 2<sup>53</sup> - 1보다 큰 수를 처리할 수 있다.
- `number` 타입과는 엄연히 다른 타입으로 상호 작용은 불가능하다.

## 6. string

- 문자열을 할당할 수 있는 타입으로 공백도 해당한다.
- 템플릿 리터럴 문법

## 7. symbol

- ES2015에서 도입된 데이터 타입으로 `Symbol()` 함수를 사용하면 어떤 값과도 중복되지 않는 유일한 값을 생성할 수 있다.

  ```ts
  const MOVIE_TITLE = Symbol("title");
  const MUSIC_TITLE = Symbol("title");
  console.log(MOVIE_TITLE === MUSIC_TITLE); // false
  ```

&nbsp;

# 4. 객체 타입

- 7가지 원시 타입에 속하지 않는 값은 모두 객체 타입으로 분류할 수 있다.

## 1. object

- 자바스크립트 객체의 정의에 대응하는 타입
- `any`와 비슷하게 객체에 해당하는 모든 타입 값을 유동적으로 할당할 수 있어 정적 타이핑의 의미가 크게 퇴색되므로 가급적 사용하지 않는 것이 좋다.
  - `any`와는 달리 원시 타입에 해당하는 값은 `object` 타입에 속하지 않는다.

## 2. {}

- 자바스크립트에서 객체 리터럴 방식으로 객체를 생성할 때 사용
- 타입스크립트에서 객체를 타이핑할 때 사용할 수 있다.
- 빈 객체의 타입으로 `{}`을 지정하면 객체에 어떤 값도 속성으로 할당할 수 없다.
  - 빈 객체의 타입을 지정할 때는 `{}`보다 유틸리티 타입으로 `Record<string, never>`처럼 사용하는 게 바람직하다.
  - `{}` 타입으로 지정된 객체는 완전히 비어있는 순수한 객체를 의미하는 것이 아니다. 자바스크립트 프로토타입 체이닝으로 `Object` 객체 래퍼에서 제공하는 속성에는 정상적으로 접근할 수 있다. → 소문자로 된 타입스크립트 타입 체계를 사용하는 게 일반적

## 3. array

- 자바스크립트의 배열 자료구조는 원소를 자유롭게 추가하고 제거할 수 있으며 타입 제 없이 다양한 값을 다룬다.
  - 하나의 배열 안에 여러 타입의 값이 혼재될 수 있다.
  - 하지만 이러한 쓰임은 타입스크립트가 추구하는 정적 타이핑 방향과 맞지 않는다.
- 타입스크립트의 `array` 타입은 하나의 타입 값만 가질 수 있다는 점에서 자바스크립트 배열보다 조금 더 엄격하다.

## 4. type과 interface 키워드

- 객체를 타이핑하기 위해 자주 사용하는 키워드로 `type`과 `interface`가 있다.

  ```ts
  interface NoticePopupType = {
      title: string;
      description: string;
  }

  interface INoticePopup = {
      title: string;
      description: string;
  }

  const noticePopup1: NoticePopupType = { ... }
  const noticePopup2: INoticePopup = { ... }
  ```

## 5. function

- 자바스크립트에서는 함수도 일종의 객체로 간주하지만 `typeof` 연산자로 함수 타입을 출력해보면 `function`이라는 별도 타입으로 분류한다.
- 타입스크립트에서는 자바스크립트에서 `typeof` 연산자로 확인한 `function`이라는 키워드 자체를 타입으로 사용하지 않는다.
- 타입스크립트에서는 함수의 매개변수도 별도 타입으로 지정해야 한다.
- 함수가 반환하는 값이 있다면 반환 값에 대한 타이핑도 필요하다.

  ```ts
  function add(a: number, b: number): number {
    return a + b;
  }
  ```

- 함수 자체의 타입은 호출 시그니처를 정의하는 방식을 사용해 지정할 수 있다.
  ```ts
  type add = (a: nuber, b: number) => number;
  ```
  > **호출 시그니처**  
  > 타입스크립트에서 함수 타입을 정의할 때 사용하는 문법  
  > 함수 타입은 해당 함수가 받는 매개변수와 반환하는 값의 타입으로 결정되는데, 호출 시그니처는 이러한 함수의 매개변수와 반환 값의 타입을 명시하는 역할을 한다.
